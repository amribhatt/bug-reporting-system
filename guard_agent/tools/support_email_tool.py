"""
Support Email Tool for Guard Agent

This tool sends email notifications to the support team about repeated issues
after the original incident was marked as resolved.
"""

import sys
import os
import smtplib
from datetime import datetime
from typing import Dict, Any
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from google.adk.tools.tool_context import ToolContext

# Add parent directory to path to import config
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from config import get_email_config, get_support_email, get_sender_email, is_email_enabled


def send_support_email(user_id: str, user_email: str, repeated_issue: str, original_incident_id: str, tool_context: ToolContext) -> dict:
    """
    Tool to send email notifications to support team about repeated issues.
    
    Args:
        user_id: The user's ID
        user_email: The user's email address
        repeated_issue: Description of the repeated issue
        original_incident_id: The original incident ID that was resolved
        tool_context: Context for accessing session state
        
    Returns:
        Dictionary containing email sending result
    """
    print(f"--- Tool: send_support_email called for repeated issue ---")
    
    # Input validation and sanitization
    if not all([user_id, user_email, repeated_issue, original_incident_id]):
        return {
            "action": "send_support_email",
            "status": "error",
            "message": "Missing required parameters for email notification"
        }
    
    # Sanitize inputs to prevent injection
    user_id = str(user_id).strip()[:50]  # Limit length
    user_email = str(user_email).strip()[:100]
    repeated_issue = str(repeated_issue).strip()[:1000]  # Limit issue description
    original_incident_id = str(original_incident_id).strip()[:20]
    
    # Get email configuration from centralized config
    try:
        support_email = get_support_email()
        email_user = get_sender_email()
        email_config = get_email_config()
        smtp_server = email_config["smtp_server"] if email_config else "smtp.gmail.com"
        smtp_port = email_config["smtp_port"] if email_config else 587
        email_password = email_config["email_password"] if email_config else None
        
        # Security check: Ensure password is properly configured
        if not email_password or email_password in ["your_password", "password", "default"]:
            print(f"[EMAIL ALERT] Email password not configured securely")
            return {
                "action": "send_support_email",
                "status": "disabled",
                "message": "Email notifications require proper password configuration"
            }
        
        # Check if email is enabled
        if not is_email_enabled():
            print(f"[EMAIL ALERT] Email notifications are disabled in configuration")
            return {
                "action": "send_support_email",
                "status": "disabled",
                "message": "Email notifications are disabled in configuration"
            }
        
        # Rate limiting: Check recent email alerts to prevent spam
        email_alerts = tool_context.state.get("email_alerts", [])
        recent_alerts = [
            alert for alert in email_alerts 
            if alert.get("user_id") == user_id and 
            (datetime.now() - datetime.fromisoformat(alert.get("timestamp", "1970-01-01"))).total_seconds() < 3600  # Last hour
        ]
        
        if len(recent_alerts) >= 3:  # Max 3 emails per user per hour
            print(f"[EMAIL ALERT] Rate limit exceeded for user {user_id}")
            return {
                "action": "send_support_email",
                "status": "rate_limited",
                "message": "Email rate limit exceeded. Please wait before sending more notifications."
            }
        
        # Create email content
        subject = f"REPEATED ISSUE ALERT - User {user_id} - Original Incident {original_incident_id}"
        
        body = f"""
        REPEATED ISSUE ALERT
        
        A user has reported the same issue again after the original incident was marked as resolved.
        
        User Details:
        - User ID: {user_id}
        - Email: {user_email}
        - Original Incident: {original_incident_id}
        
        Issue Description:
        {repeated_issue}
        
        This indicates that the original resolution may not have been effective or the issue has reoccurred.
        Please review the original incident and consider:
        1. Whether the resolution was actually implemented
        2. If the issue is a recurring system problem
        3. If additional follow-up with the user is needed
        
        Time: {datetime.now().isoformat()}
        
        This email was automatically generated by the Bug Reporting System.
        """
        
        # Send the actual email
        try:
            # Create email message
            msg = MIMEMultipart()
            msg['From'] = email_user
            msg['To'] = support_email
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))
            
            # Send email via SMTP
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.starttls()  # Enable encryption
                server.login(email_user, email_password)
                server.send_message(msg)
            
            print(f"[EMAIL ALERT] ‚úÖ Email sent successfully to {support_email}")
            email_status = "sent"
            
        except Exception as email_error:
            print(f"[EMAIL ALERT] ‚ùå Failed to send email: Authentication or connection error")
            print(f"[EMAIL ALERT] üìù Email content logged for manual review")
            print(f"[EMAIL ALERT] To: {support_email}")
            print(f"[EMAIL ALERT] Subject: {subject}")
            print(f"[EMAIL ALERT] Body preview: {body[:200]}...")
            # Do not log actual email_error as it may contain credentials
            email_status = "failed"
        
        # Store email alert in session state for tracking
        email_alerts = tool_context.state.get("email_alerts", [])
        email_alerts.append({
            "timestamp": datetime.now().isoformat(),
            "user_id": user_id,
            "user_email": user_email,
            "original_incident_id": original_incident_id,
            "repeated_issue": repeated_issue[:100],
            "support_email": support_email,
            "status": email_status
        })
        max_alerts = email_config["max_email_alerts"] if email_config else 50
        tool_context.state["email_alerts"] = email_alerts[-max_alerts:]  # Keep last N alerts
        
        return {
            "action": "send_support_email",
            "status": email_status,
            "message": f"Support email alert {'sent' if email_status == 'sent' else 'failed'} to {support_email} regarding repeated issue for user {user_id}",
            "original_incident_id": original_incident_id,
            "alert_timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        print(f"[Support Email Tool] Error: Email configuration or authentication issue")
        return {
            "action": "send_support_email",
            "status": "error",
            "message": "Failed to send support email: Email configuration or authentication issue"
        } 